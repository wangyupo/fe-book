# 展开嵌套数组

### flat

> 该方法会按照一个`可指定`的`深度`递归遍历数组，并将所有元素与遍历到的`子数组`中的元素合并为`一个新数组`返回。

它的语法是：

> var newArray = arr.flat(depth) \
其中`depth`是指定要提取嵌套`数组`的结构`深度`，默认值为 1。

```js
let arr1 = [1, 2, [3, 4]];
arr1.flat(); 
// [1, 2, 3, 4]

let arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]
```

### some + concat + apply

> apply() 方法调用一个具有给定 `this值` 的 `函数` ，以及作为一个 `数组（或类似数组对象）` 提供的 `参数` ，语法如下：

```js
func.apply(thisArg, [argsArray])
```

解决办法如下：

```js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))){
        arr = [].concat.apply([], arr);
    }
    return arr;
}
var arr = [1, [2, 3, [4]], "a", "b", ["c", "d"], [["d"],"e"], "f"];  
console.log(flatten(arr)) 
// [1, 2, 3, 4, "a", "b", "c", "d", "d", "e", "f"]
```

**concat** 的作用是把参数中的数组项合并到一个结果数组中去，如下：

```js
[].concat(1,[2,3],[4])
// [1,2,3,4]
```

而 **some** 可以帮我们`判断`当前数组下面还有没有数组，所以这个方法解释起来就是：

> 如果数组里面还包含数组，就创建一个空数组，将当前数组作为concat的参数传进去，赋值给当前数组，然后再判断新的数组内是否还有数组。

为什么不用 `[].concat(arr)` ，而是要用 `[].concat.apply([], arr)` 呢？

这样做的原因是为了将数组作为concat的`参数`传进去，这样做看起来就像 `[].concat(1,[2,3],4)` ，而不是 `[].concat([1,[2,3],4])` ，从而能起到合并数组的作用。当然了，`...`(展开运算符)也能起到同样的作用，所以可以改写为如下函数：

```js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))){
        arr = [].concat(...arr);
    }
    return arr;
}
var arr = [1, [2, 3, [4]], "a", "b", ["c", "d"], [["d"],"e"], "f"];  
console.log(flatten(arr)) 
// [1, 2, 3, 4, "a", "b", "c", "d", "d", "e", "f"]
```

总结该函数核心理念如下：

> 将数组各项`展开`传入`concat`中，递归判断，不断展开，直到子项没有数组项为止。


